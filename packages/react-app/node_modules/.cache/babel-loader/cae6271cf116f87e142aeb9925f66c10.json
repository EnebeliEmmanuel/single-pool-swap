{"ast":null,"code":"var _jsxFileName = \"/home/kokocodes/single-pool-dex/packages/react-app/src/components/SwapTab.jsx\",\n    _s = $RefreshSig$();\n\nimport { ethers } from \"ethers\";\nimport React, { useState, useEffect } from \"react\";\nimport SwapFormRow from \"./SwapFormRow\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst contractName = \"DEX\";\nconst tokenName = \"Balloons\";\nexport default function SwapTab(props) {\n  _s();\n\n  const [liquidityError, setLiquidityError] = useState(false);\n  const tx = props.tx;\n  const writeContracts = props.writeContracts;\n  const [fromEth, setFromEth] = useState(true);\n  const [currentEthValue, setCurrentEthValue] = useState(\"\");\n  const [currentBalloonsValue, setCurrentBalloonsValue] = useState(\"\");\n  const [ethFixed, setEthFixed] = useState(true);\n  useEffect(() => {\n    //runs when swap direction changes or text fields are changed to calculate prices\n    updatePriceCalculations();\n  }, [fromEth, ethFixed, currentEthValue, currentBalloonsValue]);\n\n  const updatePriceCalculations = async () => {\n    //calculate the floating price as required based on fromEth and ethFixed\n    let fixedValue = ethFixed ? currentEthValue : currentBalloonsValue; //handle blank input box\n\n    if (fixedValue == \"\") {\n      setCurrentBalloonsValue(\"\");\n      setCurrentEthValue(\"\");\n      console.log(\"not calculating price with blank input\");\n    } else {\n      let fixedValueInEther = ethers.utils.parseEther(\"\" + fixedValue);\n      let calculatedPrice = 0;\n\n      if (fromEth) {\n        if (ethFixed) {\n          calculatedPrice = await props.readContracts[contractName].estimateEthToToken(fixedValueInEther);\n        } else {\n          try {\n            calculatedPrice = await props.readContracts[contractName].estimateEthRequiredForTokens(fixedValueInEther);\n            setLiquidityError(false);\n          } catch (e) {\n            console.log(e);\n            console.log(\"not enough Ballons liquidity\");\n            setLiquidityError(true);\n          }\n        }\n      } else {\n        if (ethFixed) {\n          try {\n            calculatedPrice = await props.readContracts[contractName].estimateTokensRequiredForEth(fixedValueInEther);\n            setLiquidityError(false);\n          } catch (e) {\n            console.log(e);\n            console.log(\"not enough Eth liquidity\");\n            setLiquidityError(true);\n          }\n        } else {\n          calculatedPrice = await props.readContracts[contractName].estimateTokenToEth(fixedValueInEther);\n        }\n      }\n\n      let formattedPrice = (Math.round(ethers.utils.formatEther(calculatedPrice) * 100) / 100).toFixed(2); //the value should probably only be rounded in the UI rather than rounding the actual value\n\n      ethFixed == true ? setCurrentBalloonsValue(formattedPrice) : setCurrentEthValue(formattedPrice);\n    }\n  };\n\n  const switchDirection = e => {\n    e.preventDefault();\n    setFromEth(!fromEth);\n    setLiquidityError(false);\n  };\n\n  const handleSwapButton = e => {\n    e.preventDefault();\n    let zeroError = false;\n\n    if (currentEthValue == 0 || currentEthValue == \"\") {\n      zeroError = true;\n    }\n\n    if (!liquidityError & !zeroError) {\n      fromEth == true ? swapEthToToken(currentEthValue) : swapTokenToEth(currentBalloonsValue);\n    }\n  };\n\n  const swapEthToToken = async value => {\n    console.log(\"Swapping...\");\n    let valueInEther = ethers.utils.parseEther(\"\" + value);\n    let swapEthToTokenResult = await tx(writeContracts[contractName][\"ethToToken\"]({\n      value: valueInEther\n    }));\n    console.log(\"swapEthToTokenResult:\", swapEthToTokenResult);\n  };\n\n  const swapTokenToEth = async value => {\n    let valueInEther = ethers.utils.parseEther(\"\" + value);\n    console.log(\"valueInEther\", valueInEther);\n    let allowance = await props.readContracts[tokenName].allowance(props.address, props.readContracts[contractName].address);\n    console.log(\"allowance\", allowance);\n    let approveTx;\n\n    if (allowance.lt(valueInEther)) {\n      approveTx = await tx(writeContracts[tokenName].approve(props.readContracts[contractName].address, valueInEther, {\n        gasLimit: 200000\n      }));\n    }\n\n    let swapTx = tx(writeContracts[contractName][\"tokenToEth\"](valueInEther, {\n      gasLimit: 200000\n    }));\n\n    if (approveTx) {\n      console.log(\"waiting on approve to finish...\");\n      let approveTxResult = await approveTx;\n      console.log(\"approveTxResult:\", approveTxResult);\n    }\n\n    let swapTxResult = await swapTx;\n    console.log(\"swapTxResult:\", swapTxResult);\n  };\n\n  const theme = window.localStorage.getItem(\"theme\"); //handle change of text in ETH input\n\n  const setEthValue = value => {\n    setCurrentEthValue(value);\n    setEthFixed(true);\n  }; //handle change of text in ballons input\n\n\n  const setBaloonsValue = value => {\n    setCurrentBalloonsValue(value);\n    setEthFixed(false);\n  };\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"simple-ui-card\",\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"form-group\",\n      children: [/*#__PURE__*/_jsxDEV(SwapFormRow, {\n        contracts: props.readContracts,\n        address: props.address,\n        asset: fromEth ? \"ether\" : \"balloons\",\n        changeValueFunction: fromEth ? setEthValue : setBaloonsValue,\n        value: fromEth ? currentEthValue : currentBalloonsValue,\n        yourLocalBalance: props.yourLocalBalance\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 143,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: e => switchDirection(e),\n        id: \"swap-direction-button\",\n        children: \"\\u2B07\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 152,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(SwapFormRow, {\n        contracts: props.readContracts,\n        address: props.address,\n        asset: fromEth ? \"balloons\" : \"ether\",\n        changeValueFunction: fromEth ? setBaloonsValue : setEthValue,\n        value: fromEth ? currentBalloonsValue : currentEthValue,\n        yourLocalBalance: props.yourLocalBalance\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 156,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: e => handleSwapButton(e),\n        id: \"execute-swap-button\",\n        className: liquidityError ? \"liquidity-error-btn\" : \"execute-swap-btn\" // style={{ background: `${liquidityError ? \"red\" : '#252149' }` }}\n        ,\n        children: liquidityError ? \"Not enough liquidity\" : \"Swap\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 164,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 142,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 140,\n    columnNumber: 5\n  }, this);\n}\n\n_s(SwapTab, \"IBNQBP3TXhOixGWIqk8uK+anRag=\");\n\n_c = SwapTab;\n\nvar _c;\n\n$RefreshReg$(_c, \"SwapTab\");","map":{"version":3,"sources":["/home/kokocodes/single-pool-dex/packages/react-app/src/components/SwapTab.jsx"],"names":["ethers","React","useState","useEffect","SwapFormRow","contractName","tokenName","SwapTab","props","liquidityError","setLiquidityError","tx","writeContracts","fromEth","setFromEth","currentEthValue","setCurrentEthValue","currentBalloonsValue","setCurrentBalloonsValue","ethFixed","setEthFixed","updatePriceCalculations","fixedValue","console","log","fixedValueInEther","utils","parseEther","calculatedPrice","readContracts","estimateEthToToken","estimateEthRequiredForTokens","e","estimateTokensRequiredForEth","estimateTokenToEth","formattedPrice","Math","round","formatEther","toFixed","switchDirection","preventDefault","handleSwapButton","zeroError","swapEthToToken","swapTokenToEth","value","valueInEther","swapEthToTokenResult","allowance","address","approveTx","lt","approve","gasLimit","swapTx","approveTxResult","swapTxResult","theme","window","localStorage","getItem","setEthValue","setBaloonsValue","yourLocalBalance"],"mappings":"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","sourcesContent":["import { ethers } from \"ethers\";\nimport React, { useState, useEffect } from \"react\";\nimport SwapFormRow from \"./SwapFormRow\";\n\nconst contractName = \"DEX\";\nconst tokenName = \"Balloons\";\n\nexport default function SwapTab(props) {\n\n  const [liquidityError, setLiquidityError] = useState(false);\n\n  const tx = props.tx;\n\n  const writeContracts = props.writeContracts;\n\n  const [fromEth, setFromEth] = useState(true);\n  const [currentEthValue, setCurrentEthValue] = useState(\"\");\n  const [currentBalloonsValue, setCurrentBalloonsValue] = useState(\"\");\n  const [ethFixed, setEthFixed] = useState(true);\n\n  useEffect(() => {\n    //runs when swap direction changes or text fields are changed to calculate prices\n\n    updatePriceCalculations();\n  }, [fromEth, ethFixed, currentEthValue, currentBalloonsValue]);\n\n  const updatePriceCalculations = async () => {\n    //calculate the floating price as required based on fromEth and ethFixed\n\n    let fixedValue = ethFixed ? currentEthValue : currentBalloonsValue;\n\n    //handle blank input box\n    if (fixedValue == \"\") {\n      setCurrentBalloonsValue(\"\");\n      setCurrentEthValue(\"\");\n      console.log(\"not calculating price with blank input\");\n    } else {\n      let fixedValueInEther = ethers.utils.parseEther(\"\" + fixedValue);\n      let calculatedPrice = 0;\n      if (fromEth) {\n        if (ethFixed) {\n          calculatedPrice = await props.readContracts[contractName].estimateEthToToken(fixedValueInEther);\n        } else {\n          try {\n            calculatedPrice = await props.readContracts[contractName].estimateEthRequiredForTokens(fixedValueInEther);\n            setLiquidityError(false);\n          } catch (e) {\n            console.log(e);\n            console.log(\"not enough Ballons liquidity\");\n\n            setLiquidityError(true);\n          }\n        }\n      } else {\n        if (ethFixed) {\n          try {\n            calculatedPrice = await props.readContracts[contractName].estimateTokensRequiredForEth(fixedValueInEther);\n            setLiquidityError(false);\n          } catch (e) {\n            console.log(e);\n            console.log(\"not enough Eth liquidity\");\n            setLiquidityError(true);\n          }\n        } else {\n          calculatedPrice = await props.readContracts[contractName].estimateTokenToEth(fixedValueInEther);\n        }\n      }\n      let formattedPrice = (Math.round(ethers.utils.formatEther(calculatedPrice) * 100) / 100).toFixed(2);\n      //the value should probably only be rounded in the UI rather than rounding the actual value\n      ethFixed == true ? setCurrentBalloonsValue(formattedPrice) : setCurrentEthValue(formattedPrice);\n    }\n  };\n\n  const switchDirection = e => {\n    e.preventDefault();\n    setFromEth(!fromEth);\n    setLiquidityError(false);\n  };\n  const handleSwapButton = e => {\n    e.preventDefault();\n    let zeroError = false;\n    if (currentEthValue == 0 || currentEthValue == \"\") {\n      zeroError = true;\n    }\n    if (!liquidityError & !zeroError) {\n      fromEth == true ? swapEthToToken(currentEthValue) : swapTokenToEth(currentBalloonsValue);\n    }\n  };\n\n  const swapEthToToken = async value => {\n    console.log(\"Swapping...\");\n    let valueInEther = ethers.utils.parseEther(\"\" + value);\n    let swapEthToTokenResult = await tx(writeContracts[contractName][\"ethToToken\"]({ value: valueInEther }));\n    console.log(\"swapEthToTokenResult:\", swapEthToTokenResult);\n  };\n\n  const swapTokenToEth = async value => {\n    let valueInEther = ethers.utils.parseEther(\"\" + value);\n    console.log(\"valueInEther\", valueInEther);\n    let allowance = await props.readContracts[tokenName].allowance(\n      props.address,\n      props.readContracts[contractName].address,\n    );\n    console.log(\"allowance\", allowance);\n\n    let approveTx;\n    if (allowance.lt(valueInEther)) {\n      approveTx = await tx(\n        writeContracts[tokenName].approve(props.readContracts[contractName].address, valueInEther, {\n          gasLimit: 200000,\n        }),\n      );\n    }\n\n    let swapTx = tx(writeContracts[contractName][\"tokenToEth\"](valueInEther, { gasLimit: 200000 }));\n    if (approveTx) {\n      console.log(\"waiting on approve to finish...\");\n      let approveTxResult = await approveTx;\n      console.log(\"approveTxResult:\", approveTxResult);\n    }\n    let swapTxResult = await swapTx;\n    console.log(\"swapTxResult:\", swapTxResult);\n  };\n\n  const theme = window.localStorage.getItem(\"theme\");\n\n  //handle change of text in ETH input\n  const setEthValue = value => {\n    setCurrentEthValue(value);\n    setEthFixed(true);\n  };\n\n  //handle change of text in ballons input\n  const setBaloonsValue = value => {\n    setCurrentBalloonsValue(value);\n    setEthFixed(false);\n  };\n\n  return (\n    <div className=\"simple-ui-card\">\n      \n      <div className=\"form-group\">\n        <SwapFormRow\n        contracts={props.readContracts}\n        address={props.address}\n          asset={fromEth ? \"ether\" : \"balloons\"}\n          changeValueFunction={fromEth ? setEthValue : setBaloonsValue}\n          value={fromEth ? currentEthValue : currentBalloonsValue}\n          yourLocalBalance={props.yourLocalBalance}\n        />\n\n        <button onClick={e => switchDirection(e)} id=\"swap-direction-button\">\n          ⬇\n        </button>\n\n        <SwapFormRow\n        contracts={props.readContracts}\n        address={props.address}\n          asset={fromEth ? \"balloons\" : \"ether\"}\n          changeValueFunction={fromEth ? setBaloonsValue : setEthValue}\n          value={fromEth ? currentBalloonsValue : currentEthValue}\n          yourLocalBalance={props.yourLocalBalance}\n        />\n        <button\n          onClick={e => handleSwapButton(e)}\n          id=\"execute-swap-button\"\n          className={liquidityError ? \"liquidity-error-btn\" : \"execute-swap-btn\" }\n          // style={{ background: `${liquidityError ? \"red\" : '#252149' }` }}\n        >\n          {liquidityError ? \"Not enough liquidity\" : \"Swap\"}\n        </button>\n      </div>\n    </div>\n  );\n}\n"]},"metadata":{},"sourceType":"module"}